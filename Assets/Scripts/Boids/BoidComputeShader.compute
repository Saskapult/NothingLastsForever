
#pragma kernel CSMain



StructuredBuffer<float3> boidPositions;
StructuredBuffer<float3> boidVelocities;

StructuredBuffer<float3> targetPositions;
StructuredBuffer<float3> avoidPositions;


RWStructuredBuffer<float3> boidForces;



float separationRadius;
float alignmentRadius;
float cohesionRadius;
float targetRadius;
float avoidRadius;

float separationFactor;
float alignmentFactor;
float cohesionFactor;
float targetFactor;
float avoidFactor;

bool separationFov;
bool alignmentFov;
bool cohesionFov;
bool targetFov;
bool avoidFov;

float boidFov;



[numthreads(256,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint thisBoid = id.x;


    float3 position = boidPositions[thisBoid];
    float3 velocity = boidVelocities[thisBoid];


    float totalSeparationWeight = 0.0f;
    float totalAlignmentWeight = 0.0f;
    float totalCohesionWeight = 0.0f;

    float3 separationForce = float3(0, 0, 0);
    float3 alignmentForce = float3(0, 0, 0);
    float3 cohesionForce = float3(0, 0, 0);


    if (length(position) > 10.0f)
    {
        boidForces[thisBoid] = -position;
        return;
    }


    for (uint otherBoid = 0; otherBoid < boidPositions.Length; otherBoid++)
    {
        if (thisBoid == otherBoid) continue;

        float3 otherPosition = boidPositions[otherBoid];
        float3 otherVelocity = boidVelocities[otherBoid];

        float3 toOther = otherPosition - position;
        float distance = length(toOther);

        
        float angle = acos(dot(velocity, toOther) / (length(velocity) * length(toOther)));

        bool otherVisible = angle < 0.5f * boidFov;


        // Separation
        if (distance < separationRadius && (!separationFov || otherVisible))
        {
            float weight = 1.0f - (distance / separationRadius);

            totalSeparationWeight += weight;

            separationForce += weight * -1.0f * toOther;
        }


        // Alignment
        if (distance < alignmentRadius && (!alignmentFov || otherVisible))
        {
            float weight = 1.0f - (distance / alignmentRadius);

            totalAlignmentWeight += weight;

            alignmentForce += weight * otherVelocity;
        }


        // Cohesion
        if (distance < cohesionRadius && (!cohesionFov || otherVisible))
        {
            float weight = 1.0f - (distance / cohesionRadius);

            totalCohesionWeight += weight;

            cohesionForce += weight * toOther;
        }
    }


    if (totalSeparationWeight > 0.01f)
        separationForce /= totalSeparationWeight;

    if (totalAlignmentWeight > 0.01f)
        alignmentForce = (alignmentForce / totalAlignmentWeight) - velocity;

    if (totalCohesionWeight > 0.01f)
        cohesionForce /= totalCohesionWeight;


    boidForces[thisBoid] = (separationFactor * separationForce)
                         + (alignmentRadius * alignmentForce)
                         + (cohesionRadius * cohesionForce);
}
