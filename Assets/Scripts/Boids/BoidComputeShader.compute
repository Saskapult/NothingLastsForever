
#pragma kernel CSMain



StructuredBuffer<float3> boidPositions;
StructuredBuffer<float3> boidVelocities;

StructuredBuffer<float3> targetPositions;
StructuredBuffer<float3> avoidPositions;


RWStructuredBuffer<float3> boidForces;



float separationRadius;
float alignmentRadius;
float cohesionRadius;
float targetRadius;
float avoidRadius;

float separationFactor;
float alignmentFactor;
float cohesionFactor;
float targetFactor;
float avoidFactor;

bool separationFov;
bool alignmentFov;
bool cohesionFov;
bool targetFov;
bool avoidFov;

float halfFovRad;


float3 SteerTowards(float3 localTarget, float3 velocity)
{
	float distance = length(localTarget);

	if (distance < 0.0001f)
		return float3(0, 0, 0);

	localTarget /= distance;

	float dotProduct = dot(localTarget, velocity);

	if (dotProduct > 0.9999f)
		return float3(0, 0, 0);

	float3 steering = localTarget - velocity;

	return steering;
}



[numthreads(256,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint thisBoid = id.x;


    float3 position = boidPositions[thisBoid];


    if (length(position) > 20.0f)
    {
        boidForces[thisBoid] = -position;

        //return;
    }

    float3 velocity = boidVelocities[thisBoid];


    float totalSeparationWeight = 0.0f;
    float totalAlignmentWeight = 0.0f;
    float totalCohesionWeight = 0.0f;
    float totalTargetWeight = 0.0f;
    float totalAvoidWeight = 0.0f;

    float3 averageSeparationLocation = float3(0, 0, 0);
    float3 averageAlignmentVelocity = float3(0, 0, 0);
    float3 averageCohesionLocation = float3(0, 0, 0);
    float3 averageTargetLocation = float3(0, 0, 0);
    float3 averageAvoidLocation = float3(0, 0, 0);


    for (uint otherBoid = 0; otherBoid < boidPositions.Length; otherBoid++)
    {
        if (thisBoid == otherBoid) continue;

        float3 otherPosition = boidPositions[otherBoid];
        float3 otherVelocity = boidVelocities[otherBoid];

        float3 toOther = otherPosition - position;
        float distanceToOther = distance(position, otherPosition);

        
        float3 toOtherNormalized = normalize(toOther);
        float3 velocityNormalized = normalize(velocity);

        float dotProduct = dot(velocityNormalized, toOtherNormalized);
        dotProduct = clamp(dotProduct, -1.0f, 1.0f);
        float angle = acos(dotProduct);
        bool otherVisible = angle < halfFovRad;


        // Separation
        if (distanceToOther < separationRadius && (!separationFov || otherVisible))
        {
            float weight = 1.0f;// - (distanceToOther / separationRadius);

            totalSeparationWeight += weight;

            averageSeparationLocation += weight * toOther;
        }


        // Alignment
        if (separationRadius < distanceToOther && distanceToOther < alignmentRadius && (!alignmentFov || otherVisible))
        {
            float weight = 1.0f;// - (distanceToOther / alignmentRadius);

            totalAlignmentWeight += weight;

            averageAlignmentVelocity += weight * otherVelocity;
        }


        // Cohesion
        if (separationRadius < distanceToOther && distanceToOther < cohesionRadius && (!cohesionFov || otherVisible))
        {
            float weight = 1.0f;// - (distanceToOther / cohesionRadius);

            totalCohesionWeight += weight;

            averageCohesionLocation += weight * toOther;
        }
    }



    for (uint target = 0; target < targetPositions.Length; target++)
    {
        float3 targetPosition = targetPositions[target];

		float3 toTarget = targetPosition - position;
		float distanceToTarget = distance(position, targetPosition);
        
        float3 toOtherNormalized = normalize(toTarget);
        float3 velocityNormalized = normalize(velocity);

        float dotProduct = dot(velocityNormalized, toOtherNormalized);
        dotProduct = clamp(dotProduct, -1.0f, 1.0f);
        float angle = acos(dotProduct);
        bool targetVisible = angle < halfFovRad;

		if (distanceToTarget < targetRadius && (!targetFov || targetVisible))
		{
			float weight = 1.0f;// - (distanceToTarget / targetRadius);

			totalTargetWeight += weight;

			averageTargetLocation += weight * toTarget;
		}
    }



    for (uint avoid = 0; avoid < avoidPositions.Length; avoid++)
    {
        float3 avoidPosition = avoidPositions[target];

		float3 toAvoid = avoidPosition - position;
		float distanceToAvoid = distance(position, avoidPosition);
        
        float3 toOtherNormalized = normalize(toAvoid);
        float3 velocityNormalized = normalize(velocity);

        float dotProduct = dot(velocityNormalized, toOtherNormalized);
        dotProduct = clamp(dotProduct, -1.0f, 1.0f);
        float angle = acos(dotProduct);
        bool avoidVisible = angle < halfFovRad;

		if (distanceToAvoid < targetRadius && (!avoidFov || avoidVisible))
		{
			float weight = 1.0f;// - (distanceToTarget / targetRadius);

			totalAvoidWeight += weight;

			averageAvoidLocation += weight * toAvoid;
		}
    }


  //  if (totalSeparationWeight > 0.0001f)
  //      averageSeparationLocation /= totalSeparationWeight;
  //  else
		//averageSeparationLocation = float3(0, 0, 0);

    //if (totalAlignmentWeight > 0.01f)
    //    averageAlignmentVelocity /= totalAlignmentWeight;
    //else
    //    averageAlignmentVelocity = float3(0, 0, 0);

    if (totalCohesionWeight > 0.0001f)
        averageCohesionLocation /= totalCohesionWeight;
    else
        averageCohesionLocation = float3(0, 0, 0);

    if (totalTargetWeight > 0.0001f)
        averageTargetLocation /= totalTargetWeight;
    else
        averageTargetLocation = float3(0, 0, 0);


    float3 steeringForce = (separationFactor * SteerTowards(-averageSeparationLocation, velocity))
                         + (alignmentFactor * SteerTowards(averageAlignmentVelocity, velocity))
                         + (cohesionFactor * SteerTowards(averageCohesionLocation, velocity))
                         + (targetFactor * SteerTowards(averageTargetLocation, velocity))
                         + (avoidFactor * SteerTowards(-averageAvoidLocation, velocity));


    boidForces[thisBoid] = steeringForce;
}
